#include "list.hpp"

void list_test()
{
    ListNode* pNode1 = CreateListNode(1);
    ListNode* pNode2 = CreateListNode(2);
    ListNode* pNode3 = CreateListNode(3);
    ListNode* pNode4 = CreateListNode(4);
    ListNode* pNode5 = CreateListNode(5);

    ConnectionListNodes(pNode1, pNode2);
    ConnectionListNodes(pNode2, pNode3);
    ConnectionListNodes(pNode3, pNode4);
    ConnectionListNodes(pNode4, pNode5);

    PrintList(pNode1);
}

/*
 * BM1  反转链表
 * 将链表反转，即将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。

step 1：优先处理空链表，空链表不需要反转。
step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。
step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。
step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。
 */
class Solution1 {
public:
    ListNode* ReverseList(ListNode* pHead)
    {
        ListNode* pPrev = nullptr;
        ListNode* pCurrent = pHead;

        while(pCurrent != nullptr)
        {
            ListNode* pNext = pCurrent->m_pNext;

            pCurrent->m_pNext = pPrev;

            pPrev = pCurrent;
            pCurrent = pNext;
        }

        return pPrev;
    }

    void test_reverseList()
    {
        ListNode* pNode1 = CreateListNode(1);
        ListNode* pNode2 = CreateListNode(2);
        ListNode* pNode3 = CreateListNode(3);
        ListNode* pNode4 = CreateListNode(4);
        ListNode* pNode5 = CreateListNode(5);

        ConnectionListNodes(pNode1, pNode2);
        ConnectionListNodes(pNode2, pNode3);
        ConnectionListNodes(pNode3, pNode4);
        ConnectionListNodes(pNode4, pNode5);
        ListNode* pReversedHead = ReverseList(pNode1);

        PrintList(pReversedHead);
    }


};

/*
 * 链表内指定区间反转
 * 将链表反转，即将每个表元的指针从向后变成向前，那我们可以遍历原始链表，将遇到的节点一一指针逆向即可。

step 1：优先处理空链表，空链表不需要反转。
step 2：我们可以设置两个指针，一个当前节点的指针，一个上一个节点的指针（初始为空）。
step 3：遍历整个链表，每到一个节点，断开当前节点与后面节点的指针，并用临时变量记录后一个节点，然后当前节点指向上一个节点，即可以将指针逆向。
step 4：再轮换当前指针与上一个指针，让它们进入下一个节点及下一个节点的前序节点。
 */
class Solution2 {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode* pPre = new ListNode(-1);
        pPre->m_pNext = head;
        ListNode* result = pPre;
        ListNode* pCurNode = head;

        for(int i = 1; i < m; i++)
        {
            pPre = pCurNode;
            pCurNode = pCurNode->m_pNext;
        }

        for(int i = m; i < n; i++)
        {
            ListNode* temp = pCurNode->m_pNext;
            pCurNode->m_pNext = temp->m_pNext;
            temp->m_pNext = pPre->m_pNext;
            pPre->m_pNext = temp;
        }

        return result->m_pNext;
    }

    
    void test_reverseBetween()
    {
        ListNode* pNode1 = CreateListNode(1);
        ListNode* pNode2 = CreateListNode(2);
        ListNode* pNode3 = CreateListNode(3);
        ListNode* pNode4 = CreateListNode(4);
        ListNode* pNode5 = CreateListNode(5);

        ConnectionListNodes(pNode1, pNode2);
        ConnectionListNodes(pNode2, pNode3);
        ConnectionListNodes(pNode3, pNode4);
        ConnectionListNodes(pNode4, pNode5);
        ListNode* pReversedHead = reverseBetween(pNode1, 2, 4);

        PrintList(pReversedHead);
    }


};

/*
 * 链表中的节点每k个一组翻转
 *
 * 解题思路
 刷题模板
step 1：现在我们想一想，如果拿到一个链表，想要像上述一样分组翻转应该做些什么？首先肯定是分段吧，至少我们要先分成一组一组，才能够在组内翻转。分组很容易，只要每次遍历k个元素，就是一组。
step 2：然后是组内翻转，翻转完了再连接起来。翻转即指定区间内的翻转，也很容易，可以参考[链表指定区间内的翻转]。
step 3：最后是将反转后的分组连接，但是连接的时候遇到问题了：首先如果能够翻转，链表第一个元素一定是第一组，它翻转之后就跑到后面去了，而第一组的末尾元素才是新的链表首，我们要返回的也是这个元素，而原本的链表首要连接下一组翻转后的头部，即翻转前的尾部，如果不建立新的链表，看起来就会非常难。
step 4：如果我们从最后的一个组开始翻转，得到了最后一个组的链表首，是不是可以直接连在倒数第二个组翻转后的尾（即翻转前的头）后面，是不是看起来就容易多了。
 */
class Solution3{
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr || k <= 0)
            return nullptr;

        ListNode* tail = head;
        for(int i = 0; i < k; i ++)
        {
            if(tail == nullptr)
                return head;
            tail = tail->m_pNext;
        }

        ListNode* pPrev = nullptr;
        ListNode* pCur = head;

        while(pCur != tail)
        {
            ListNode* pNext = pCur->m_pNext;


            pCur->m_pNext = pPrev;
            pPrev = pCur;
            pCur = pNext;
        }

        head->m_pNext = reverseKGroup(tail, k);

        return pPrev;
    }
    

    void test_reverseKGroup()
    {
        ListNode* pNode1 = CreateListNode(1);
        ListNode* pNode2 = CreateListNode(2);
        ListNode* pNode3 = CreateListNode(3);
        ListNode* pNode4 = CreateListNode(4);
        ListNode* pNode5 = CreateListNode(5);

        ConnectionListNodes(pNode1, pNode2);
        ConnectionListNodes(pNode2, pNode3);
        ConnectionListNodes(pNode3, pNode4);
        ConnectionListNodes(pNode4, pNode5);
        ListNode* pReversedHead = reverseKGroup(pNode1, 2);

        PrintList(pReversedHead);
    }
};

/*
 *  合并两个排序的链表
 *
 *  step 1：判断空链表的情况，只要有一个链表为空，那答案必定就是另一个链表了，就算另一个链表也为空。
step 2：新建一个空的表头后面连接两个链表排序后的结点。
step 3：遍历两个链表都不为空的情况，取较小值添加在新的链表后面，每次只把被添加的链表的指针后移。
step 4：遍历到最后肯定有一个链表还有剩余的结点，它们的值将大于前面所有的，直接连在新的链表后面即可。
 */

class Solution4
{
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(pHead1 == nullptr)
            return pHead2;
        else if(pHead2 == nullptr)
            return pHead1;

        ListNode* pMerged = new ListNode(-1);
        ListNode* result = pMerged;

        while(pHead1 != nullptr && pHead2 != nullptr)
        {
            if(pHead1->m_nValue <= pHead2->m_nValue)
            {
                pMerged = pHead1;
                pHead1 = pHead1->m_pNext;
            }
            if(pHead1->m_nValue > pHead2->m_nValue)
            {
                pMerged = pHead2;
                pHead2 = pHead2->m_pNext;
            }

            pMerged = pMerged->m_pNext;
        }

        if(pHead1 != nullptr)
            pMerged->m_pNext = pHead1;
        if(pHead2 != nullptr)
            pMerged->m_pNext = pHead2;

        return result;
    }

    void test_Merge()
    {
        ListNode* pNode1 = CreateListNode(1);
        ListNode* pNode2 = CreateListNode(2);
        ListNode* pNode3 = CreateListNode(3);
        ListNode* pNode4 = CreateListNode(4);
        ListNode* pNode5 = CreateListNode(5);

        ConnectionListNodes(pNode1, pNode3);
        ConnectionListNodes(pNode2, pNode4);
        ConnectionListNodes(pNode4, pNode5);

        ListNode* pMergeHead = Merge(pNode1, pNode2);

        PrintList(pMergeHead);
    }

};

int main()
{
    //list_test();
    
    //链表反转测试
//    Solution1 s1;
//    s1.test_reverseList();

//    Solution2 s2;
//    s2.test_reverseBetween();

//    Solution3 s3;
//    s3.test_reverseKGroup();

    Solution4 s4;
    s4.test_Merge();

    return 0;
}
